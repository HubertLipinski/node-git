#! /usr/bin/env node
import{Command as e,Option as t}from"commander";import r from"node:fs";import o from"path";import n from"node:zlib";import i from"node:crypto";import{EOL as s}from"os";import a from"node:assert";const c=process.cwd(),m=process.env._NODE_GIT_DIRECTORY??".nodegit",d=o.join(c,m),l=(...e)=>0===e.length?d:o.join(d,...e);const f=()=>{r.mkdirSync(d,{recursive:!0}),r.mkdirSync(l("objects"),{recursive:!0}),r.mkdirSync(l("refs","heads"),{recursive:!0}),r.writeFileSync(l("HEAD"),"ref: refs/heads/master\n")},p=e=>({directory:e.slice(0,2),filename:e.slice(2)}),u=e=>{const t=p(e);return r.existsSync(l("objects",t.directory,t.filename))},h=(e,t=!0)=>{const r=p(e);return t?l("objects",r.directory,r.filename):`${r.directory}/${r.filename}`},g=e=>{const t=(e=>{const t=p(e),o=l("objects",t.directory,t.filename);if(!u(e))throw new Error(`File not found: ${e}`);return r.readFileSync(o)})(e),o=n.inflateSync(t),i=o.toString(),s=i.split(" ")[0],a=i.split(" ")[1].split("\0")[0],c=o.subarray(s.length+a.length+2);return{type:s,size:parseInt(a),content:c}},y=(e,t)=>{const o=p(e);r.mkdirSync(l("objects",o.directory),{recursive:!0}),r.writeFileSync(h(e),t)},w=e=>{switch(e){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";default:throw new Error(`Unknown file mode: ${e}`)}};var b=(e,t)=>{const r=g(e);if(t.t)process.stdout.write(r.type);else if(t.s)process.stdout.write(r.size.toString());else if(t.p)if("blob"!==r.type){if("tree"!==r.type){if("commit"===r.type)return console.info("Object type: Commit"),void process.stdout.write(r.content.toString());throw new Error(`Unknown object ${e}`)}{const e=(e=>{const t=[];let r=0;for(;r<e.length-40+1;){const o=e.indexOf(0,r),[n,i]=e.subarray(r,o).toString("utf8").split(" "),s=e.subarray(o+1,o+40+1).toString("utf8");r=o+40+1,t.push({mode:n,type:w(n),hash:s,filename:i})}return t})(r.content);process.stdout.write(e.map((e=>`${e.mode} ${e.type} ${e.hash}    ${e.filename}`)).join("\n"))}}else{const e=r.content.toString().split("\0").join("");process.stdout.write(e)}else process.stdout.write("Missing option -p")};const S=(e,t="hex")=>i.createHash("sha1").update(e).digest(t),$=e=>{if(!r.existsSync(e))throw new Error(`File not found: ${e}`);const t=r.readFileSync(e),o=`blob ${t.length}\0${t}`,i=S(o),s=n.deflateSync(o);return y(i,s),i};function x(e="./"){const t=(()=>{const e=".nodegitignore",t=o.join(process.cwd(),e);return r.existsSync(t)?r.readFileSync(o.join(process.cwd(),e),"utf-8").toString().split(s).filter((e=>""!==e.trim())):[]})(),i=r.readdirSync(e).filter((e=>!t.includes(e))),a=[];i.forEach((t=>{const n=o.join(e,t);r.lstatSync(n).isDirectory()?a.push({mode:"040000",filename:t,hash:x(n)}):a.push({mode:"100644",filename:t,hash:$(n)})}));const c=a.reduce(((e,{mode:t,filename:r,hash:o})=>Buffer.concat([e,Buffer.from(`${t} ${r}\0`),Buffer.from(o,"utf-8")])),Buffer.alloc(0)),m=Buffer.concat([Buffer.from(`tree ${c.length}\0`),c]),d=n.deflateSync(m),l=S(m);return r.mkdirSync(h(l.slice(0,2)),{recursive:!0}),r.writeFileSync(h(l),d),l}const j=e=>{if(!u(e))throw new Error(`Commit does not exist: ${e}`);const t=g(e),r=Buffer.from(t.content).toString().split("\n\n"),[o,n]=[r[0],r[1]],i=v(n);return o.split("\n").map((e=>{const[t,...r]=e.split(" ");switch(t){case"author":case"commiter":i[t]={name:r[0],email:r[1],date:`${r[2]} ${r[3]}`};break;case"tree":case"parent":i[t]=r[0]}})),i},v=e=>({tree:"",parent:null,commiter:{name:"",email:"",date:""},author:{name:"",email:"",date:""},message:e});var E=(e,t)=>((e,t,r="Default commit message")=>{if(!u(e))throw new Error(`Object does not exist: ${e}`);if(t&&!u(t))throw new Error(`Parent does not exist: ${e}`);const o=`User user@example.com ${Math.floor(Date.now()/1e3)} +0000`;let i=`tree ${e}\nauthor ${o}\ncommiter ${o}\n\n${r}\n`;t&&(i=`tree ${e}\nparent ${t}\nauthor ${o}\ncommiter ${o}\n\n${r}\n`);const s=`commit ${i.length}\0`+i,a=S(s);return y(a,n.deflateSync(s)),a})(e,t.parent,t.message);const I=()=>{const e=l("index");if(!r.existsSync(e))return[];const t=r.readFileSync(e,"binary"),o=Buffer.from(t,"binary"),n=o.subarray(0,12),i=n.subarray(0,4);a("DIRC"===i.toString(),"Invalid signature");const s=n.readUIntBE(4,4);a(2===s,"Only version 2 is supported");const c=n.readUIntBE(8,4),m=[];let d=0;const f=o.subarray(n.length);for(let e=0;e<c;e++){const e=f.subarray(d,d+4),t=f.subarray(d+8,d+12),r=f.subarray(d+16,d+20),o=f.subarray(d+20,d+24),n=f.subarray(d+24,d+28),i=f.subarray(d+28,d+32),s=f.subarray(d+32,d+36),a=f.readUInt32BE(d+36),c=f.subarray(d+40,d+60),l=f.readUIntBE(d+60,2).toString(2),p=l[0].toString(),u=l[1].toString(),h=parseInt(l.slice(1,3),2),g=4095&parseInt(l,2);let y=null;if(d+=62,!(g<4095))throw new Error(`File name length is too long: ${g} > 4095 bytes`);y=f.subarray(d,d+g).toString("utf8"),d+=g+1,d=8*Math.ceil(d/8),m.push({createdTime:D(e),modifiedTime:D(t),dev:r.toString("hex"),ino:o.toString("hex"),mode:n.toString("hex"),uid:i.toString("hex"),gid:s.toString("hex"),size:a,hash:c.toString("hex"),fileName:y,flags:{binary:l.toString(),valid:p,extended:u,stage:h.toString(2)}})}return m},D=e=>new Date(1e3*parseInt(e.toString("hex"),16)),F=(e,t=!1)=>{const o=t?e:l(e);if(!r.existsSync(o)){if("refs/heads/master"===e)throw new Error("This is empty repository. Make some changes first.");return null}const n=r.readFileSync(o).toString().trim();return n.startsWith("ref: ")?F(n.slice(5)):n},C=(e,t=null,r=!0)=>{const o=(e=>{if(0===e.trim().length)throw new Error("Whoops...");if("HEAD"===e)return[F(e)];const t=[];/^[0-9a-f]{40}$/.test(e)&&t.push(e);const r=F(`refs/tags/${e}`);r&&t.push(r);const o=F(`refs/heads/${e}`);return o&&t.push(o),t})(e);if(0===o.length)throw new Error(`No such reference: ${e}`);if(o.length>1)throw new Error(`Ambiguous reference: ${e} \n Candidates: ${o.join(", ")}`);const n=o[0],i=g(n);return t&&i.type!=t?r?"commit"==i.type?j(n).tree:n:null:n};var O=()=>{const e=(()=>{const e=r.readFileSync(l("HEAD")).toString().trim();return e.startsWith("ref: refs/heads/")?e.slice(16):null})();I(),e?process.stdout.write(`On branch ${e}\n`):process.stdout.write(`HEAD detached at ${e}\n`),process.stdout.write("Changes to be committed:\n"),F("HEAD")};const k=(e=null)=>{e||(e=l("refs"));const t=new Map,n=r.readdirSync(e);for(const i of n){const n=o.join(e,i);if(r.statSync(n).isDirectory()){const e=k(n);for(const[r,o]of e)t.set(r,o)}else{const e=F(n,!0);let r=o.relative(d,n);"\\"===o.sep&&(r=r.replace(/\\/g,"/")),t.set(r,e)}}return t};const B=(new e).name("node-git").usage("[option] <command>").version("1.0.0","-v, --version","Output the current version");B.command("init").description("Create an empty node-git repository or reinitialize an existing one.").option("-f","Force reinitialization of existing repository").usage(" ").action((e=>(e=>{!r.existsSync(d)||e.f?(process.stdout.write(r.existsSync(d)?`Reinitialized existing node-git repository in ${d}`:`Initialized empty node-git repository in ${d}`),f()):process.stdout.write("Detected existing node-git repository. Use -f flag to force reinitialize.")})(e))),B.command("cat-file").description("Provide information for repository objects.").argument("<sha1>","Object hash").option("-p","Pretty print object content").option("-t","Instead of the content, show the object type identified by <object>").option("-s","Instead of the content, show the object size identified by <object>").usage("[-pt] <sha1>").action(((e,t)=>{b(e,t)})),B.command("hash-object").description("Calculate SHA1 hash of given file and optionally create a blob from given file.").argument("<file>","Path to file").option("-w","Write object to repository").usage("[-w] <file>").action(((e,t)=>{process.stdout.write(((e,t)=>{const o=r.readFileSync(e),n=`blob ${o.length}\0${o}`;return t.w?$(e):S(n)})(e,t))})),B.command("write-tree").description("Create a tree object from the current index.").action((()=>{process.stdout.write(x())})),B.command("commit-tree").description("Create a new commit object").argument("<tree>","Existing tree object").addOption(new t("-p, --parent <hash>","Commit parent")).addOption(new t("-m, --message <string>","Commit message").makeOptionMandatory()).usage("<tree> [-pm]").action(((e,t)=>{console.log(e,t),process.stdout.write(E(e,t))})),B.command("log").description("Show commit logs").argument("<commit>","Commit to start at.").usage("<commit>").action((e=>{console.log((e=>{if(!e)throw new Error("Not implemented, provide hash");e.slice(0,7);const t=j(e);return t.message=t.message.split("\n")[0],j(e)})(e))})),B.command("ls-files").description("Show information about files in the index and the working tree").action((()=>{console.log(I())})),B.command("show-ref").description("List references in a local repository").action((()=>{(()=>{const e=k();for(const[t,r]of e)process.stdout.write(`${r} ${t}\n`)})()})),B.command("status").description("Status of the working tree and the index").action((()=>{O()})),B.command("rev-parse").description("Parse revision (or other objects) identifiers").argument("<name>","Name to parse").addOption(new t("-t, --type <type>","Specify the expected type").choices(["blob","commit","tree"]).default(null)).action(((e,t)=>{((e,t=null,r=!0)=>{process.stdout.write(C(e,t,r))})(e,t.type)})),B.parse(process.argv);
