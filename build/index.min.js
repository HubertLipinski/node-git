#! /usr/bin/env node
import{Command as e,Option as t,Argument as r}from"commander";import n from"node:fs";import{stringify as o,parse as i}from"ini";import s from"path";import c from"node:zlib";import a from"node:assert";import d from"node:crypto";import{EOL as l,homedir as m}from"os";const f=process.cwd(),u=process.env._NODE_GIT_DIRECTORY??".nodegit",p=s.join(f,u),h=(...e)=>0===e.length?p:s.join(p,...e),g=(e="")=>s.join(f,e),w=s.join(p,"config");const y=()=>{n.mkdirSync(p,{recursive:!0}),n.mkdirSync(h("objects"),{recursive:!0}),n.mkdirSync(h("refs","heads"),{recursive:!0}),n.writeFileSync(h("HEAD"),"ref: refs/heads/master\n")},S=()=>{n.writeFileSync(w,o({core:{repositoryformatversion:0,filemode:!1,bare:!1}}))},b=e=>({directory:e.slice(0,2),filename:e.slice(2)}),$=e=>{const t=b(e);return n.existsSync(h("objects",t.directory,t.filename))},v=(e,t=!0)=>{const r=b(e);return t?h("objects",r.directory,r.filename):`${r.directory}/${r.filename}`},x=e=>{const t=(e=>{const t=b(e),r=h("objects",t.directory,t.filename);if(!$(e))throw new Error(`File not found: ${e}`);return n.readFileSync(r)})(e),r=c.inflateSync(t),o=r.toString(),i=o.split(" ")[0],s=o.split(" ")[1].split("\0")[0],a=r.subarray(i.length+s.length+2);return{type:i,size:parseInt(s),content:a}},E=(e,t)=>{const r=b(e);n.mkdirSync(h("objects",r.directory),{recursive:!0}),n.writeFileSync(v(e),t)},B=()=>{const e=h("index");if(!n.existsSync(e))return{version:2,size:0,entries:[]};const t=n.readFileSync(e,"binary"),r=Buffer.from(t,"binary"),o=r.subarray(0,12),i=o.subarray(0,4);a("DIRC"===i.toString(),"Invalid signature");const s=o.readUIntBE(4,4);a(2===s,"Only version 2 is supported");const c=o.readUIntBE(8,4),d=[];let l=0;const m=r.subarray(o.length);for(let e=0;e<c;e++){const e=m.subarray(l,l+4),t=m.subarray(l+8,l+12),r=m.subarray(l+16,l+20),n=m.subarray(l+20,l+24),o=m.subarray(l+24,l+28),i=m.subarray(l+28,l+32),s=m.subarray(l+32,l+36),c=m.readUInt32BE(l+36),a=m.subarray(l+40,l+60),f=m.readUIntBE(l+60,2).toString(2),u=f[0].toString(),p=f[1]?.toString()??"-1",h=parseInt(f.slice(1,3),2),g=4095&parseInt(f,2);let w=null;if(l+=62,!(g<4095))throw new Error(`File name length is too long: ${g} > 4095 bytes`);w=m.subarray(l,l+g).toString("utf8"),l+=g+1,l=8*Math.ceil(l/8),d.push({createdTime:j(e),modifiedTime:j(t),dev:r.toString("hex"),ino:n.toString("hex"),mode:o.toString("hex"),uid:i.toString("hex"),gid:s.toString("hex"),size:c,hash:a.toString("hex"),fileName:w,flags:{binary:f.toString(),valid:u,extended:p,stage:h.toString(2)}})}return{version:s,size:c,entries:d}},j=e=>new Date(1e3*parseInt(e.toString("hex"),16)),F=e=>{switch(e){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";default:throw new Error(`Unknown file mode: ${e}`)}};var I=(e,t)=>{const r=x(e);if(t.t)process.stdout.write(r.type);else if(t.s)process.stdout.write(r.size.toString());else if(t.p)if("blob"!==r.type){if("tree"!==r.type){if("commit"===r.type)return console.info("Object type: Commit"),void process.stdout.write(r.content.toString());throw new Error(`Unknown object ${e}`)}{const e=(e=>{const t=[];let r=0;for(;r<e.length-40+1;){const n=e.indexOf(0,r),[o,i]=e.subarray(r,n).toString("utf8").split(" "),s=e.subarray(n+1,n+40+1).toString("utf8");r=n+40+1,t.push({mode:o,type:F(o),hash:s,filename:i})}return t})(r.content);process.stdout.write(e.map((e=>`${e.mode} ${e.type} ${e.hash}    ${e.filename}`)).join("\n"))}}else{const e=r.content.toString().split("\0").join("");process.stdout.write(e)}else process.stdout.write("Missing option -p")};const D=(e,t="hex")=>d.createHash("sha1").update(e).digest(t),U=e=>{if(!n.existsSync(e))throw new Error(`File not found: ${e}`);const t=n.readFileSync(e),r=`blob ${t.length}\0${t}`,o=D(r),i=c.deflateSync(r);return E(o,i),o};const z=()=>{const e=".gitignore",t=s.join(process.cwd(),e);if(!n.existsSync(t))return[".git"];return n.readFileSync(s.join(process.cwd(),e),"utf-8").toString().split(l).filter((e=>""!==e.trim()))},C=()=>{const e=m(),t=n.readFileSync(s.join(e,".gitconfig"),"utf-8"),r=n.readFileSync(w,"utf-8"),c=o(i(r))+o(i(t));return i(c)};function O(e="./"){const t=z(),r=n.readdirSync(e).filter((e=>!t.includes(e))),o=[];r.forEach((t=>{const r=s.join(e,t);n.lstatSync(r).isDirectory()?o.push({mode:"040000",filename:t,hash:O(r)}):o.push({mode:"100644",filename:t,hash:U(r)})}));const i=o.reduce(((e,{mode:t,filename:r,hash:n})=>Buffer.concat([e,Buffer.from(`${t} ${r}\0`),Buffer.from(n,"utf-8")])),Buffer.alloc(0)),a=Buffer.concat([Buffer.from(`tree ${i.length}\0`),i]),d=c.deflateSync(a),l=D(a);return n.mkdirSync(v(l.slice(0,2)),{recursive:!0}),n.writeFileSync(v(l),d),l}const k=(e,t,r="Default commit message")=>{if(!$(e))throw new Error(`Object does not exist: ${e}`);if(t&&!$(t))throw new Error(`Parent does not exist: ${e}`);const n=`User user@example.com ${Math.floor(Date.now()/1e3)} +0000`;let o=`tree ${e}\nauthor ${n}\ncommiter ${n}\n\n${r}\n`;t&&(o=`tree ${e}\nparent ${t}\nauthor ${n}\ncommiter ${n}\n\n${r}\n`);const i=`commit ${o.length}\0`+o,s=D(i);return E(s,c.deflateSync(i)),s},A=e=>{if(!$(e))throw new Error(`Commit does not exist: ${e}`);const t=x(e),r=Buffer.from(t.content).toString().split("\n\n"),[n,o]=[r[0],r[1]],i=N(o);return n.split("\n").map((e=>{const[t,...r]=e.split(" ");switch(t){case"author":case"commiter":i[t]={name:r[0],email:r[1],date:`${r[2]} ${r[3]}`};break;case"tree":case"parent":i[t]=r[0]}})),i},N=e=>({tree:"",parent:null,commiter:{name:"",email:"",date:""},author:{name:"",email:"",date:""},message:e});const T=()=>{const e=n.readFileSync(h("HEAD")).toString().trim().replace("\n","");return e.startsWith("ref: refs/heads/")?e.slice(16):null},H=(e=null)=>{e||(e=h("refs"));const t=new Map,r=n.readdirSync(e);for(const o of r){const r=s.join(e,o);if(n.statSync(r).isDirectory()){const e=H(r);for(const[r,n]of e)t.set(r,n)}else{const e=P(r,!0);let n=s.relative(p,r);"\\"===s.sep&&(n=n.replace(/\\/g,"/")),t.set(n,e)}}return t},M=e=>`refs/heads/${e}`,R=e=>n.existsSync((e=>h(M(e)))(e)),L=()=>{const e=n.existsSync(h("index")),t=R(T()??"master");return e&&t},P=(e,t=!1)=>{const r=t?e:h(e);if(!n.existsSync(r))return null;const o=n.readFileSync(r).toString().trim().replace("\n","");return o.startsWith("ref: ")?P(o.slice(5)):o},W=(e,t=null,r=!0)=>{const n=(e=>{if("HEAD"===e)return[P(e)];const t=[];/^[0-9a-f]{40}$/.test(e)&&t.push(e);const r=P(`refs/tags/${e}`);r&&t.push(r);const n=P(`refs/heads/${e}`);return n&&t.push(n),t})(e);if(0===n.length)throw new Error(`No such reference: ${e}`);if(n.length>1)throw new Error(`Ambiguous reference: ${e} \n Candidates: ${n.join(", ")}`);const o=n[0],i=x(o);return t&&i.type!=t?r?"commit"==i.type?A(o).tree:o:null:o};const _=(e,t=2)=>{if(0===e)return"0 B";const r=t<0?0:t,n=Math.floor(Math.log(e)/Math.log(1024));return`${parseFloat((e/Math.pow(1024,n)).toFixed(r))} ${["B","KB","MB","GB"][n]}`};var G=(e=".")=>{const t=g(e),r=z(),o=n.readdirSync(t,{recursive:!0,withFileTypes:!0}).filter((e=>{const t=s.relative(g(),e.path).split(s.sep).shift();return!r.includes(t)&&!e.isDirectory()})),i=[];for(const e of o){const t=s.join(s.resolve(e.path),e.name),r=n.statSync(t),o=U(t);i.push({createdTime:r.birthtime,modifiedTime:r.mtime,dev:r.dev.toString(16),ino:"00",mode:"0a81",uid:"00",gid:r.gid.toString(16),size:r.size,hash:o,fileName:e.name})}((e=null)=>{let t;t=null===e?B():e;const r=Buffer.alloc(12);r.write("DIRC",0),r.writeUintBE(2,4,4),r.writeUintBE(t.size,8,4);const o=Buffer.byteLength(JSON.stringify(t.entries[0]),"binary")*t.size,i=Buffer.alloc(o);let s=0;for(const e of t.entries)if(i.writeUintBE(parseInt((new Date(e.createdTime).getTime()/1e3).toFixed(0)),s,4),i.writeUintBE(0,s+4,4),i.writeUintBE(parseInt((new Date(e.modifiedTime).getTime()/1e3).toFixed(0)),s+8,4),i.writeUintBE(0,s+12,4),i.writeUintBE(parseInt(e.dev,16),s+16,4),i.writeUintBE(parseInt(e.ino,16),s+20,4),i.writeUintBE(parseInt(e.mode,16),s+24,4),i.writeUintBE(parseInt(e.uid,16),s+28,4),i.writeUintBE(parseInt(e.gid,16),s+32,4),i.writeUint32BE(e.size,s+36),Buffer.from(e.hash,"hex").copy(i,s+40),i.writeUIntBE(e.fileName.length,s+60,2),s+=62,i.write(e.fileName,s,s+e.fileName.length,"utf8"),s+=e.fileName.length+1,s%8!=0){const e=8-s%8;Buffer.alloc(e,0,"binary").copy(i,s),s+=e}n.writeFileSync(h("index"),Buffer.concat([r,i]))})({version:2,size:i.length,entries:i})};const q=(new e).name("node-git").usage("[option] <command>").version("1.0.0","-v, --version","Output the current version");q.command("init").description("Create an empty node-git repository or reinitialize an existing one.").option("-f","Force reinitialization of existing repository").usage(" ").action((e=>(e=>{!n.existsSync(p)||e.f?(process.stdout.write(n.existsSync(p)?`Reinitialized existing node-git repository in ${p}`:`Initialized empty node-git repository in ${p}`),y(),S()):process.stdout.write("Detected existing node-git repository. Use -f flag to force reinitialize.")})(e))),q.command("cat-file").description("Provide information for repository objects.").argument("<sha1>","Object hash").option("-p","Pretty print object content").option("-t","Instead of the content, show the object type identified by <object>").option("-s","Instead of the content, show the object size identified by <object>").usage("[-pt] <sha1>").action(((e,t)=>{I(e,t)})),q.command("hash-object").description("Calculate SHA1 hash of given file and optionally create a blob from given file.").argument("<file>","Path to file").option("-w","Write object to repository").usage("[-w] <file>").action(((e,t)=>{process.stdout.write(((e,t)=>{const r=n.readFileSync(e),o=`blob ${r.length}\0${r}`;return t.w?U(e):D(o)})(e,t))})),q.command("write-tree").description("Create a tree object from the current index.").action((()=>{process.stdout.write(O())})),q.command("commit-tree").description("Create a new commit object").argument("<tree>","Existing tree object").addOption(new t("-p, --parent <hash>","Commit parent")).addOption(new t("-m, --message <string>","Commit message").makeOptionMandatory()).usage("<tree> [-pm]").action(((e,t)=>{console.log(e,t),process.stdout.write(((e,t)=>k(e,t.parent,t.message))(e,t))})),q.command("log").description("Show commit logs").argument("<commit>","Commit to start at.").usage("<commit>").action((e=>{console.log((e=>{if(!e)throw new Error("Not implemented, provide hash");e.slice(0,7);const t=A(e);return t.message=t.message.split("\n")[0],A(e)})(e))})),q.command("ls-files").description("Show information about files in the index and the working tree").option("--verbose","Show verbose output").action((e=>{(e=>{const t=B();e.verbose&&process.stdout.write(`Index file version: ${t.version}, contains ${t.entries.length} entries:\n\n`),process.stdout.write("\n");for(const r of t.entries)process.stdout.write(`${r.fileName}\n`),e.verbose&&(process.stdout.write(`  sha:\t${r.hash}\n`),process.stdout.write(`  created at:\t${new Date(r.createdTime).toLocaleString("pl")}\n`),process.stdout.write(`  modified at:\t${new Date(r.modifiedTime).toLocaleString("pl")}\n`),process.stdout.write(`  size:\t${_(r.size)}\n\n`))})(e)})),q.command("show-ref").description("List references in a local repository").action((()=>{(()=>{const e=H();for(const[t,r]of e)process.stdout.write(`${r} ${t}\n`)})()})),q.command("status").description("Status of the working tree and the index").action((()=>{(()=>{const e=T();e?process.stdout.write(`On branch ${e}\n\n`):process.stdout.write(`HEAD detached at ${e}\n`),L()?(process.stdout.write("Changes to be committed:\n\n"),B(),P("HEAD")):process.stdout.write("No commits yet\n\n")})()})),q.command("rev-parse").description("Parse revision (or other objects) identifiers").argument("<name>","Name to parse").addOption(new t("-t, --type <type>","Specify the expected type").choices(["blob","commit","tree"]).default(null)).action(((e,t)=>{((e,t=null,r=!0)=>{process.stdout.write(W(e,t,r))})(e,t.type)})),q.command("checkout").description("Switch branches or restore working tree files").action((()=>{console.log("checkout")})),q.command("branch").description("List, create, or delete branches").addArgument(new r("[branch]","Branch name").default(null)).action((e=>{((e=null)=>{if(!L())return void process.stdout.write("");if(!e){const e=M(T()),t=H();return process.stdout.write("\n"),void t.forEach(((t,r)=>{process.stdout.write(`${r===e?"(*) ":""}${r}\n`)}))}if(R(e))return void process.stdout.write(`Branch '${e}' already exists\n`);const t=P("HEAD");n.writeFileSync(h(M(e)),`${t}\n`),process.stdout.write(`Created new branch: '${e}'`)})(e)})),q.command("add").description("Add file contents to the index").action((()=>{G()})),q.command("commit").description("Record changes to the repository").addOption(new t("-m, --message <message>","Commit message").default(null)).action((e=>{(e=>{if(!e)return void process.stdout.write("error: commit message is required\n");const t=O(),r=k(t,L()?W("HEAD"):null,e),o=T();o?n.writeFileSync(h(`refs/heads/${o}`),`${r}\n`):n.writeFileSync(h("HEAD"),`ref: ${r}\n`),process.stdout.write(`Commit created [${o??"HEAD"} ${r.slice(0,7)}] ${e}\n`)})(e.message)})),console.log((e=>{const t=C();if(-1===e.indexOf("."))return t[e]??null;const r=e.split(".");return a(2===r.length,"Invalid config key"),t[r[0]][r[1]]??null})("user.name")),q.parse(process.argv);
