#! /usr/bin/env node
import{Command as e,Option as t,Argument as r}from"commander";import n from"node:fs";import{stringify as o,parse as i}from"ini";import s from"path";import a from"node:zlib";import c from"node:crypto";import d from"node:assert";import{globSync as l}from"glob";import{EOL as m,homedir as u}from"os";const f=process.cwd(),p=process.env._NODE_GIT_DIRECTORY??".nodegit",h=s.join(f,p),w=(...e)=>0===e.length?h:s.join(h,...e),g=(e="")=>(Array.isArray(e)&&(e=e.join(s.sep)),s.join(f,e)),y=(e,t=!1)=>{!t&&n.existsSync(e)||n.mkdirSync(e)},$=e=>e.replaceAll("\\","/"),b=(e,t,r=!0)=>{const n=s.join(e,t);return r?$(n):n},S=s.join(h,"config");const v=()=>{n.mkdirSync(h,{recursive:!0}),n.mkdirSync(w("objects"),{recursive:!0}),n.mkdirSync(w("refs","heads"),{recursive:!0}),n.writeFileSync(w("HEAD"),"ref: refs/heads/master\n")},x=()=>{n.writeFileSync(S,o({core:{repositoryformatversion:0,filemode:!1,bare:!1}}))},E=e=>({directory:e.slice(0,2),filename:e.slice(2)}),B=e=>{const t=E(e);return n.existsSync(w("objects",t.directory,t.filename))},j=(e,t=!0)=>{const r=E(e);return t?w("objects",r.directory,r.filename):`${r.directory}/${r.filename}`},F=e=>{const t=(e=>{const t=E(e),r=w("objects",t.directory,t.filename);if(!B(e))throw new Error(`File not found: ${e}`);return n.readFileSync(r)})(e),r=a.inflateSync(t),o=r.toString(),i=o.split(" ")[0],s=o.split(" ")[1].split("\0")[0],c=r.subarray(i.length+s.length+2);return{type:i,size:parseInt(s),content:c}},D=(e,t)=>{const r=E(e);n.mkdirSync(w("objects",r.directory),{recursive:!0}),n.writeFileSync(j(e),t)},I=e=>{const t=[];let r=0;for(;r<e.length-40+1;){const n=e.indexOf(0,r),[o,i]=e.subarray(r,n).toString("utf8").split(" "),s=e.subarray(n+1,n+40+1).toString("utf8");r=n+40+1,t.push({mode:o,type:z(o),hash:s,filename:i})}return t},k=(e,t)=>{for(const r of e){const e=s.join(t,r.filename),o=F(r.hash);if("tree"===r.type){n.existsSync(e)||n.mkdirSync(e);const o=F(r.hash);k(I(o.content),`${t}/${r.filename}`)}else"blob"===r.type&&n.writeFileSync(e,o.content,{encoding:"utf-8"})}},A=(e,t,r=[])=>{t=$(t);for(const n of e){const e={path:b(t,n.filename),sha:n.hash};if("tree"===n.type){const e=F(n.hash);r.push(...A(I(e.content),`${t}/${n.filename}`))}else r.push(e)}return r},z=e=>{switch(e){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";default:throw new Error(`Unknown file mode: ${e}`)}};const C=(e,t="hex")=>c.createHash("sha1").update(e).digest(t),U=(e,t=!1)=>{if(!n.existsSync(e))throw new Error(`File not found: ${e}`);const r=n.readFileSync(e),o=`blob ${r.length}\0${r}`,i=C(o),s=a.deflateSync(o);return t||D(i,s),i};const N=(e=!1)=>{const t=[];for(const r of(()=>{const e=[{path:"",rules:[{rule:".git",ignored:!0},{rule:".git/**",ignored:!0},{rule:".nodegit",ignored:!0},{rule:".nodegit/**",ignored:!0}]}],t=n.readdirSync(g(),{recursive:!0,withFileTypes:!0}).filter((e=>".gitignore"===e.name));for(const r of t){const t=s.relative(g(),r.path),n={path:0===t.length?".":t,rules:O(s.join(r.path,".gitignore"))};e.push(n)}return e})())r.rules.forEach((n=>{let o=s.join(r.path,n.rule);e&&(o=g(o)),o=$(o),t.push(o)}));return t},O=e=>{const t=[],r=n.readFileSync(e,"utf-8").toString().split(m);for(const e of r){const r=T(e);r&&t.push(r)}return t},T=e=>{const t=e.replace(m,"").trim().replaceAll(/\\/g,"/");switch(t[0]??""){case"#":case"":return null;case"!":return{rule:H(t.slice(1)),ignored:!1};case"\\":return{rule:H(t.slice(1)),ignored:!0};default:return{rule:H(t),ignored:!0}}},H=e=>e.endsWith("/")?e+"**":e,M=e=>new Date(1e3*parseInt(e.toString("hex"),16)),R=()=>{const e=w("index");if(!n.existsSync(e))return{version:2,size:0,entries:[]};const t=n.readFileSync(e,"binary"),r=Buffer.from(t,"binary"),o=r.subarray(0,12),i=o.subarray(0,4);d("DIRC"===i.toString(),"Invalid signature");const s=o.readUIntBE(4,4);d(2===s,"Only version 2 is supported");const a=o.readUIntBE(8,4),c=[];let l=0;const m=r.subarray(o.length);for(let e=0;e<a;e++){const e=m.subarray(l,l+4),t=m.subarray(l+8,l+12),r=m.subarray(l+16,l+20),n=m.subarray(l+20,l+24),o=m.subarray(l+24,l+28),i=m.subarray(l+28,l+32),s=m.subarray(l+32,l+36),a=m.readUInt32BE(l+36),d=m.subarray(l+40,l+60),u=m.readUIntBE(l+60,2).toString(2),f=u[0].toString(),p=u[1]?.toString()??"-1",h=parseInt(u.slice(1,3),2),w=4095&parseInt(u,2);let g=null;if(l+=62,!(w<4095))throw new Error(`File name length is too long: ${w} > 4095 bytes`);g=m.subarray(l,l+w).toString("utf8"),l+=w+1,l=8*Math.ceil(l/8),c.push({createdTime:M(e),modifiedTime:M(t),dev:r.toString("hex"),ino:n.toString("hex"),mode:o.toString("hex"),uid:i.toString("hex"),gid:s.toString("hex"),size:a,hash:d.toString("hex"),fileName:g,flags:{binary:u.toString(),valid:f,extended:p,stage:h.toString(2)}})}return{version:s,size:a,entries:c}},P=(e=null)=>{let t;t=null===e?R():e;const r=Buffer.alloc(12);r.write("DIRC",0),r.writeUintBE(2,4,4),r.writeUintBE(t.size,8,4);const o=Buffer.byteLength(JSON.stringify(t.entries[0]),"binary")*t.size,i=Buffer.alloc(o);let s=0;for(const e of t.entries){i.writeUintBE(parseInt((e.createdTime.getTime()/1e3).toFixed(0)),s,4),i.writeUintBE(0,s+4,4),i.writeUintBE(parseInt((e.modifiedTime.getTime()/1e3).toFixed(0)),s+8,4),i.writeUintBE(0,s+12,4),i.writeUintBE(parseInt(e.dev,16),s+16,4),i.writeUintBE(parseInt(e.ino,16),s+20,4),i.writeUintBE(parseInt(e.mode,16),s+24,4),i.writeUintBE(parseInt(e.uid,16),s+28,4),i.writeUintBE(parseInt(e.gid,16),s+32,4),i.writeUint32BE(e.size,s+36);if(Buffer.from(e.hash,"hex").copy(i,s+40),i.writeUIntBE(e.fileName.length,s+60,2),s+=62,i.write(e.fileName,s,s+e.fileName.length,"utf8"),s+=e.fileName.length+1,s%8!=0){const e=8-s%8;Buffer.alloc(e,0,"binary").copy(i,s),s+=e}}n.writeFileSync(w("index"),Buffer.concat([r,i]))},L=(e="**",t={},r=!1)=>l(e,{ignore:N(r),dot:!0,...t});function q(e="."){e=$(g(e));const t=L("*",{root:"",cwd:e,stat:!0,withFileTypes:!0},!0),r=[];for(const e of t)e.isDirectory()?r.push({mode:"040000",filename:e.name,hash:q(s.relative(g(),e.fullpath()))}):r.push({mode:"100644",filename:e.name,hash:U(e.fullpath())});const o=r.reduce(((e,{mode:t,filename:r,hash:n})=>Buffer.concat([e,Buffer.from(`${t} ${r}\0`),Buffer.from(n,"utf-8")])),Buffer.alloc(0)),i=Buffer.concat([Buffer.from(`tree ${o.length}\0`),o]),c=a.deflateSync(i),d=C(i);return n.mkdirSync(j(d.slice(0,2)),{recursive:!0}),n.writeFileSync(j(d),c),d}const W=e=>{const t=_();if(-1===e.indexOf("."))return t[e]??null;const r=e.split(".");return d(2===r.length,"Invalid config key"),t[r[0]][r[1]]??null},_=()=>{const e=u(),t=n.readFileSync(s.join(e,".gitconfig"),"utf-8"),r=n.readFileSync(S,"utf-8"),a=o(i(r))+o(i(t));return i(a)},G=(e,t,r="Default commit message")=>{if(!B(e))throw new Error(`Object does not exist: ${e}`);if(t&&!B(t))throw new Error(`Parent does not exist: ${e}`);const n=W("user.name"),o=W("user.email");if(!n||!o)throw new Error("User name and email are not set. Please set them in the config file.");const i=`${n} ${o} ${Math.floor(Date.now()/1e3)}`;let s=`tree ${e}\nauthor ${i}\ncommiter ${i}\n\n${r}\n`;t&&(s=`tree ${e}\nparent ${t}\nauthor ${i}\ncommiter ${i}\n\n${r}\n`);const c=`commit ${s.length}\0`+s,d=C(c);return D(d,a.deflateSync(c)),d},J=e=>{if(!B(e))throw new Error(`Commit does not exist: ${e}`);const t=F(e),r=Buffer.from(t.content).toString().split("\n\n"),[n,o]=[r[0],r[1]],i=K(o);return n.split("\n").map((e=>{const[t,...r]=e.split(" ");let n=r[0],o=r[1],s=`${r[2]} ${r[3]??""}`;switch(r.length>3&&(n=`${r[0]} ${r[1]}`,o=`${r[2]}`,s=`${r[3]} ${r[4]??""}`),t){case"author":case"commiter":i[t]={name:n.trim(),email:o.trim(),date:s.trim()};break;case"tree":case"parent":i[t]=r[0]}})),i},K=e=>({tree:"",parent:null,commiter:{name:"",email:"",date:""},author:{name:"",email:"",date:""},message:e});const Y=(e=null)=>{e||(e=w("refs"));const t=new Map,r=n.readdirSync(e);for(const o of r){const r=s.join(e,o);if(n.statSync(r).isDirectory()){const e=Y(r);for(const[r,n]of e)t.set(r,n)}else{const e=te(r,!0);let n=s.relative(h,r);"\\"===s.sep&&(n=$(n)),t.set(n,e)}}return t},Q=e=>`refs/heads/${e}`,V=e=>n.existsSync((e=>w(Q(e)))(e)),X=(e,t=37)=>`[${t}m${e}[0m`,Z=()=>{const e=n.readFileSync(w("HEAD")).toString().trim().replace("\n","");return e.startsWith("ref: refs/heads/")?e.slice(16):null},ee=()=>{const e=n.existsSync(w("index"));if(!e)return!1;const t=V(Z()??"master");return e&&t},te=(e,t=!1)=>{const r=t?e:w(e);if(!n.existsSync(r))return null;const o=n.readFileSync(r).toString().trim().replace("\n","");return o.startsWith("ref: ")?te(o.slice(5)):o},re=(e,t=null,r=!0)=>{const n=(e=>{if("HEAD"===e)return[te(e)];const t=[];/^[0-9a-f]{40}$/.test(e)&&t.push(e);const r=te(`refs/tags/${e}`);r&&t.push(r);const n=te(`refs/heads/${e}`);return n&&t.push(n),t})(e);if(0===n.length)throw new Error(`No such reference: ${e}`);if(n.length>1)throw new Error(`Ambiguous reference: ${e} \n Candidates: ${n.join(", ")}`);const o=n[0],i=F(o);return t&&i.type!=t?r?"commit"==i.type?J(o).tree:o:null:o};const ne=(e,t)=>{process.stdout.write(X(`commit ${e}\n`,33)),process.stdout.write(`Author ${t.author.name} <${t.author.email}>\n`),process.stdout.write(`Date: ${new Date(1e3*parseInt(t.author.date)).toLocaleString("pl")}\n\n`),process.stdout.write(`\t${t.message}\n`)},oe=()=>new Promise((e=>{const t=process.stdin.isRaw;process.stdin.setRawMode(!0),process.stdin.resume(),process.stdin.once("data",(r=>{process.stdin.pause(),process.stdin.setRawMode(t),e(r.toString())}))}));const ie=()=>{const e=Z();e?process.stdout.write(`On branch ${e}\n\n`):process.stdout.write(`HEAD detached at ${e}\n`)},se=e=>{process.stdout.write("Changes to be committed:\n");const t=re("HEAD","tree"),r=F(t),n=I(r.content),o=A(n,"."),i=e.entries.reduce(((e,t)=>(e[t.hash]=t.fileName,e)),{}),s=o.reduce(((e,t)=>(e[t.path]=t.sha,e)),{});for(const[e,t]of Object.entries(i))s[t]?(s[t]!==e&&process.stdout.write(X(`\tmodified: ${t}\n`,32)),delete s[t]):process.stdout.write(X(`\tnew file: ${t}\n`,32));for(const e of Object.keys(s))process.stdout.write(X(`\tdeleted: ${e}\n`,31))},ae=e=>{process.stdout.write("\nChanges not staged for commit:\n");const t=L("**",{root:"",cwd:g(),stat:!0,nodir:!0,withFileTypes:!0},!0),r=new Map;for(const e of t){const t=$(e.relative());r.set(t,{fileName:t,createdTime:e.birthtime??new Date,modifiedTime:e.mtime??new Date,size:e.size??0})}for(const t of e.entries){const e=t.fileName,o=r.get(e)??null;if(!o){process.stdout.write(X(`\tdeleted: ${e}\n`,31));continue}if(!(n=o.modifiedTime,new Date(1e3*Math.round(n.getTime()/1e3))!==t.modifiedTime)){r.delete(e);continue}U(g(e),!0)!==t.hash&&process.stdout.write(X(`\tmodified: ${e}\n`,31)),r.delete(e)}var n;process.stdout.write("\nUntracked files:\n");for(const e of r.keys())process.stdout.write(X(`\tnew file: ${e}\n`,31))};const ce=(e,t=2)=>{if(0===e)return"0 B";const r=t<0?0:t,n=Math.floor(Math.log(e)/Math.log(1024));return`${parseFloat((e/Math.pow(1024,n)).toFixed(r))} ${["B","KB","MB","GB"][n]}`};var de=(e=null,t={})=>{if(ee()){if(!e){const e=Q(Z()),t=Y();return process.stdout.write("\n"),void t.forEach(((t,r)=>{process.stdout.write(`${r===e?"* "+X(r,32):r}\n`)}))}t.delete?(e=>{V(e)?Z()!==e?(n.unlinkSync(w(Q(e))),process.stdout.write(`Branch '${e}' has been deleted!`)):process.stdout.write(X(`Currently on ${e}. Checkout to another branch before deleting!`,33)):process.stdout.write(X(`Cannot delete ${e}. Branch does not exist!`,31))})(e):V(e)?process.stdout.write(`Branch '${e}' already exists\n`):(e=>{const t=te("HEAD");n.writeFileSync(w(Q(e)),`${t}\n`),process.stdout.write(`Created new branch: '${e}'`)})(e)}},le=(e=".")=>{const t=s.relative(g(),g([".",e])),r=L("**",{nodir:!0,cwd:t,stat:!0,withFileTypes:!0}),n=[];let o=R().entries;const i=(()=>{const e=R(),t=new Map;for(const r of e.entries)t.set(r.fileName,r.hash);return t})();for(const e of r){const t=$(s.relative(g(),e.fullpath())),r=U(e.fullpath()),a=o.find((e=>e.fileName===t)),c=i.has(t)&&i.get(t)!==r,d={createdTime:e.birthtime,modifiedTime:e.mtime,dev:e?.dev?.toString(16),ino:e.ino?.toString(32),mode:e.mode?.toString(16),uid:e.uid?.toString(16),gid:e.gid?.toString(16),size:e.size,hash:r,fileName:t};a?c&&n.push(d):o.push(d)}o=o.map((e=>n.find((t=>t.fileName===e.fileName))||e)),P({version:2,size:o.length,entries:o})},me=e=>{if(!e)return void process.stdout.write("error: commit message is required\n");if(!(R().size>0))return process.stdout.write("No changes added to commit.\n"),void process.stdout.write("Use node-git add to add changes to the index file.\n");const t=q(),r=G(t,ee()?re("HEAD"):null,e),o=Z();o?n.writeFileSync(w(`refs/heads/${o}`),`${r}\n`):n.writeFileSync(w("HEAD"),`ref: ${r}\n`),process.stdout.write(`Commit created [${o??"HEAD"} ${r.slice(0,7)}] ${e}\n`)};const ue=(new e).name("node-git").usage("[option] <command>").version("1.0.0","-v, --version","Output the current version");ue.command("init").description("Create an empty node-git repository or reinitialize an existing one.").option("-f","Force reinitialization of existing repository").usage(" ").action((e=>(e=>{!n.existsSync(h)||e.f?(process.stdout.write(n.existsSync(h)?`Reinitialized existing node-git repository in ${h}`:`Initialized empty node-git repository in ${h}`),v(),x()):process.stdout.write("Detected existing node-git repository. Use -f flag to force reinitialize.")})(e))),ue.command("cat-file").description("Provide information for repository objects.").argument("<sha1>","Object hash").option("-p","Pretty print object content").option("-t","Instead of the content, show the object type identified by <object>").option("-s","Instead of the content, show the object size identified by <object>").usage("[-pt] <sha1>").action(((e,t)=>{((e,t)=>{const r=F(e);if(t.t)process.stdout.write(r.type);else if(t.s)process.stdout.write(r.size.toString());else if(t.p)if("blob"!==r.type)if("tree"!==r.type){if("commit"!==r.type)throw new Error(`Unknown object ${e}`);process.stdout.write(r.content.toString())}else{const e=I(r.content);process.stdout.write(e.map((e=>`${e.mode} ${e.type} ${e.hash}    ${e.filename}`)).join("\n"))}else{const e=r.content.toString().split("\0").join("");process.stdout.write(e)}else process.stdout.write("Missing option -p")})(e,t)})),ue.command("hash-object").description("Calculate SHA1 hash of given file and optionally create a blob from given file.").argument("<file>","Path to file").option("-w","Write object to repository").usage("[-w] <file>").action(((e,t)=>{process.stdout.write(((e,t)=>{const r=n.readFileSync(e),o=`blob ${r.length}\0${r}`;return t.w?U(e):C(o)})(e,t))})),ue.command("write-tree").description("Create a tree object from the current index.").argument("[path]","Root of the tree. Relative to the working directory.").usage("[path]").action((e=>{process.stdout.write(q(e))})),ue.command("commit-tree").description("Create a new commit object").argument("<tree>","Existing tree object").addOption(new t("-p, --parent <hash>","Commit parent")).addOption(new t("-m, --message <string>","Commit message").makeOptionMandatory()).usage("<tree> [-pm]").action(((e,t)=>{process.stdout.write(((e,t)=>G(e,t.parent,t.message))(e,t))})),ue.command("log").description("Show commit logs").addArgument(new r("[commit]","Commit to start at.").default(null).argOptional()).usage("<commit>").action((e=>{(async e=>{if(!ee())return null;process.stdout.write("\n"),process.stdout.write("Press 'q' to quit, any other key to continue\n"),process.stdout.write("\n");const t=re(e??"HEAD"),r=J(t);if(ne(t,r),null===r.parent)return;let n=re(r.parent),o=J(n);for(ne(n,o);null!==o.parent;)"q"===(await oe()).toLowerCase()&&process.exit(0),n=re(o.parent),o=J(n),ne(n,o)})(e)})),ue.command("ls-files").description("Show information about files in the index and the working tree").option("--verbose","Show verbose output. Includes details about the files.").action((e=>{(e=>{const t=R();e.verbose&&process.stdout.write(`Index file version: ${t.version}, contains ${t.entries.length} entries:\n\n`),process.stdout.write("\n");for(const r of t.entries)process.stdout.write(`${r.fileName}\n`),e.verbose&&(process.stdout.write(`  sha:\t${r.hash}\n`),process.stdout.write(`  created at:\t${r.createdTime.toLocaleString("pl")}\n`),process.stdout.write(`  modified at:\t${r.modifiedTime.toLocaleString("pl")}\n`),process.stdout.write(`  size:\t${ce(r.size)}\n\n`))})(e)})),ue.command("show-ref").description("List references in a local repository").action((()=>{(()=>{const e=Y();for(const[t,r]of e)process.stdout.write(`${r} ${t}\n`)})()})),ue.command("status").description("Show status of the working tree and the index").action((()=>{(()=>{ee()||process.exit(0);const e=R();ie(),se(e),ae(e)})()})),ue.command("rev-parse").description("Parse revision (or other objects) identifiers").argument("<name>","Name to parse").addOption(new t("-t, --type <type>","Specify the expected type").choices(["blob","commit","tree"]).default(null)).usage("<name> [--type <type>]").action(((e,t)=>{((e,t=null,r=!0)=>{process.stdout.write(re(e,t,r))})(e,t.type)})),ue.command("checkout").description("Switch branches or restore working tree files").argument("<branch-name>","Name of the branch").addArgument(new r("[directory]","Empty directory to write files to").default(".")).addOption(new t("-b --branch","Create a new branch named <branch-name>")).addOption(new t("--commit <commit>","Restore working tree files from the given commit. This will detach HEAD from the current branch.")).usage("<branch-name> [--commit <commit>] [directory]").action(((e,t,r)=>{((e,t,r)=>{if(r.commit){const e=r.commit.toString(),o=re(e),i=F(o),s=g(t);return y(s),k(I(i.content),s),n.writeFileSync(w("HEAD"),`ref: ${e}\n`),void process.stdout.write(`HEAD detached at ${e}`)}if(r.branch&&(de(e),process.stdout.write("\n")),!V(e))return void process.stdout.write(`Branch '${e}' does not exist`);const o=Q(e),i=te(o),s=J(i).tree,a=F(s),c=g(t);y(c),k(I(a.content),c),n.writeFileSync(w("HEAD"),`ref: ${o}\n`),process.stdout.write(`Switched to branch '${e}'`)})(e,t,r)})),ue.command("branch").description("List, create, or delete branches").addArgument(new r("[branch]","Branch name. When not provided, displays list of all branches").default(null)).addOption(new t("-d --delete","Create a new branch named <branch-name>")).action(((e,t)=>{de(e,t)})),ue.command("add").addArgument(new r("[path]","Path to directory or a file").default(null)).description("Add file contents to the index").action((e=>{le(e)})),ue.command("rm").addArgument(new r("<paths...>","Files to remove").argRequired()).description("Remove files from the working tree and the index.").action((e=>{(e=>{const t=[...R().entries];for(const[r,o]of t.entries())e.includes(o.fileName)&&(t.splice(r,1),n.unlinkSync(o.fileName));P({version:2,size:t.length,entries:t})})(e)})),ue.command("commit").description("Record changes to the repository").addOption(new t("-m, --message <message>","Commit message").makeOptionMandatory(!0)).usage("-m <message>").action((e=>{me(e.message)})),ue.command("show-ignore").description("Show all ignored paths. Reads all .gitignore files in the repository.").action((()=>{(()=>{process.stdout.write("Ignored files:\n\n");const e=N();for(const t of e)process.stdout.write(t+"\n")})()})),ue.parse(process.argv);
