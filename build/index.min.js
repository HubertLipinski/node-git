#! /usr/bin/env node
import{Command as e}from"commander";import t from"node:fs";import o from"path";import i from"node:zlib";import r from"node:crypto";import{EOL as n}from"os";const s=process.cwd(),c=process.env._NODE_GIT_DIRECTORY??".nodegit",a=o.join(s,c),f=(...e)=>0===e.length?a:o.join(a,...e);const d=()=>{t.mkdirSync(a,{recursive:!0}),t.mkdirSync(f("objects"),{recursive:!0}),t.mkdirSync(f("refs"),{recursive:!0}),t.writeFileSync(f("HEAD"),"ref: refs/heads/main\n")},l=e=>({directory:e.slice(0,2),filename:e.slice(2)}),p=(e,t=!0)=>{const o=l(e);return t?f("objects",o.directory,o.filename):`${o.directory}/${o.filename}`},m=e=>{const o=l(e),r=f("objects",o.directory,o.filename);if(!(e=>{const o=l(e);return t.existsSync(f("objects",o.directory,o.filename))})(e))throw new Error(`File not found: ${e}`);const n=t.readFileSync(r),s=i.inflateSync(n),c=s.toString(),a=c.split(" ")[0],d=c.split(" ")[1].split("\0")[0],p=s.subarray(a.length+d.length+2);return{type:a,size:parseInt(d),content:p}},u=e=>{switch(e){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";case"160000":return"commit";default:throw new Error(`Unknown file mode: ${e}`)}};var y=(e,t)=>{const o=m(e);if(t.t)process.stdout.write(o.type);else if(t.s)process.stdout.write(o.size.toString());else if(t.p)if("blob"!==o.type){if("tree"!==o.type){if("commit"===o.type)throw console.info("Object type: Commit"),new Error("Not implemented.");throw new Error(`Unknown object ${e}`)}{const e=(e=>{const t=[];let o=0;for(;o<e.length-40+1;){const i=e.indexOf(0,o),[r,n]=e.subarray(o,i).toString("utf8").split(" "),s=e.subarray(i+1,i+40+1).toString("utf8");o=i+40+1,t.push({mode:r,type:u(r),hash:s,filename:n})}return t})(o.content);process.stdout.write(e.map((e=>`${e.mode} ${e.type} ${e.hash}    ${e.filename}`)).join("\n"))}}else{const e=o.content.toString().split("\0").join("");process.stdout.write(e)}else process.stdout.write("Missing option -p")};const h=(e,t="hex")=>r.createHash("sha1").update(e).digest(t),g=e=>{if(!t.existsSync(e))throw new Error(`File not found: ${e}`);const o=t.readFileSync(e),r=`blob ${o.length}\0${o}`,n=h(r);return((e,o)=>{const i=l(e);t.mkdirSync(f("objects",i.directory),{recursive:!0}),t.writeFileSync(p(e),o)})(n,i.deflateSync(r)),n};function w(e="./"){const r=(()=>{const e=".nodegitignore",i=o.join(process.cwd(),e);return t.existsSync(i)?t.readFileSync(o.join(process.cwd(),e),"utf-8").toString().split(n).filter((e=>""!==e.trim())):[]})(),s=t.readdirSync(e).filter((e=>!r.includes(e))),c=[];s.forEach((i=>{const r=o.join(e,i);t.lstatSync(r).isDirectory()?c.push({mode:"040000",filename:i,hash:w(r)}):c.push({mode:"100644",filename:i,hash:g(r)})}));const a=c.reduce(((e,{mode:t,filename:o,hash:i})=>Buffer.concat([e,Buffer.from(`${t} ${o}\0`),Buffer.from(i,"utf-8")])),Buffer.alloc(0)),f=Buffer.concat([Buffer.from(`tree ${a.length}\0`),a]),d=i.deflateSync(f),l=h(f);return t.mkdirSync(p(l.slice(0,2)),{recursive:!0}),t.writeFileSync(p(l),d),l}const b=(new e).name("node-git").usage("[option] <command>").version("1.0.0","-v, --version","Output the current version");b.command("init").description("Create an empty node-git repository or reinitialize an existing one.").option("-f","Force reinitialization of existing repository").usage(" ").action((e=>(e=>{!t.existsSync(a)||e.f?(process.stdout.write(t.existsSync(a)?`Reinitialized existing node-git repository in ${a}`:`Initialized empty node-git repository in ${a}`),d()):process.stdout.write("Detected existing node-git repository. Use -f flag to force reinitialize.")})(e))),b.command("cat-file").description("Provide information for repository objects.").argument("<sha1>","Object hash").option("-p","Pretty print object content").option("-t","Instead of the content, show the object type identified by <object>").option("-s","Instead of the content, show the object size identified by <object>").usage("[-pt] <sha1>").action(((e,t)=>{y(e,t)})),b.command("hash-object").description("Calculate SHA1 hash of given file and optionally create a blob from given file.").argument("<file>","Path to file").option("-w","Write object to repository").usage("[-w] <file>").action(((e,o)=>{process.stdout.write(((e,o)=>{const i=t.readFileSync(e),r=`blob ${i.length}\0${i}`;return o.w?g(e):h(r)})(e,o))})),b.command("write-tree").description("Create a tree object from the current index.").action((()=>{process.stdout.write(w())})),b.parse(process.argv);
