#! /usr/bin/env node
import{Command as e,Option as t}from"commander";import o from"node:fs";import r from"path";import n from"node:zlib";import i from"node:crypto";import{EOL as s}from"os";import a from"node:assert";const c=process.cwd(),m=process.env._NODE_GIT_DIRECTORY??".nodegit",d=r.join(c,m),l=(...e)=>0===e.length?d:r.join(d,...e);const f=()=>{o.mkdirSync(d,{recursive:!0}),o.mkdirSync(l("objects"),{recursive:!0}),o.mkdirSync(l("refs","heads"),{recursive:!0}),o.writeFileSync(l("HEAD"),"ref: refs/heads/main\n")},p=e=>({directory:e.slice(0,2),filename:e.slice(2)}),u=e=>{const t=p(e);return o.existsSync(l("objects",t.directory,t.filename))},h=(e,t=!0)=>{const o=p(e);return t?l("objects",o.directory,o.filename):`${o.directory}/${o.filename}`},g=e=>{const t=(e=>{const t=p(e),r=l("objects",t.directory,t.filename);if(!u(e))throw new Error(`File not found: ${e}`);return o.readFileSync(r)})(e),r=n.inflateSync(t),i=r.toString(),s=i.split(" ")[0],a=i.split(" ")[1].split("\0")[0],c=r.subarray(s.length+a.length+2);return{type:s,size:parseInt(a),content:c}},y=(e,t)=>{const r=p(e);o.mkdirSync(l("objects",r.directory),{recursive:!0}),o.writeFileSync(h(e),t)},w=e=>{switch(e){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";default:throw new Error(`Unknown file mode: ${e}`)}};var b=(e,t)=>{const o=g(e);if(t.t)process.stdout.write(o.type);else if(t.s)process.stdout.write(o.size.toString());else if(t.p)if("blob"!==o.type){if("tree"!==o.type){if("commit"===o.type)return console.info("Object type: Commit"),void process.stdout.write(o.content.toString());throw new Error(`Unknown object ${e}`)}{const e=(e=>{const t=[];let o=0;for(;o<e.length-40+1;){const r=e.indexOf(0,o),[n,i]=e.subarray(o,r).toString("utf8").split(" "),s=e.subarray(r+1,r+40+1).toString("utf8");o=r+40+1,t.push({mode:n,type:w(n),hash:s,filename:i})}return t})(o.content);process.stdout.write(e.map((e=>`${e.mode} ${e.type} ${e.hash}    ${e.filename}`)).join("\n"))}}else{const e=o.content.toString().split("\0").join("");process.stdout.write(e)}else process.stdout.write("Missing option -p")};const S=(e,t="hex")=>i.createHash("sha1").update(e).digest(t),$=e=>{if(!o.existsSync(e))throw new Error(`File not found: ${e}`);const t=o.readFileSync(e),r=`blob ${t.length}\0${t}`,i=S(r),s=n.deflateSync(r);return y(i,s),i};function x(e="./"){const t=(()=>{const e=".nodegitignore",t=r.join(process.cwd(),e);return o.existsSync(t)?o.readFileSync(r.join(process.cwd(),e),"utf-8").toString().split(s).filter((e=>""!==e.trim())):[]})(),i=o.readdirSync(e).filter((e=>!t.includes(e))),a=[];i.forEach((t=>{const n=r.join(e,t);o.lstatSync(n).isDirectory()?a.push({mode:"040000",filename:t,hash:x(n)}):a.push({mode:"100644",filename:t,hash:$(n)})}));const c=a.reduce(((e,{mode:t,filename:o,hash:r})=>Buffer.concat([e,Buffer.from(`${t} ${o}\0`),Buffer.from(r,"utf-8")])),Buffer.alloc(0)),m=Buffer.concat([Buffer.from(`tree ${c.length}\0`),c]),d=n.deflateSync(m),l=S(m);return o.mkdirSync(h(l.slice(0,2)),{recursive:!0}),o.writeFileSync(h(l),d),l}const j=e=>{if(!u(e))throw new Error(`Commit does not exist: ${e}`);const t=g(e),o=Buffer.from(t.content).toString().split("\n\n"),[r,n]=[o[0],o[1]],i=v(n);return r.split("\n").map((e=>{const[t,...o]=e.split(" ");switch(t){case"author":case"commiter":i[t]={name:o[0],email:o[1],date:`${o[2]} ${o[3]}`};break;case"tree":case"parent":i[t]=o[0]}})),i},v=e=>({tree:"",parent:null,commiter:{name:"",email:"",date:""},author:{name:"",email:"",date:""},message:e});var E=(e,t)=>((e,t,o="Default commit message")=>{if(!u(e))throw new Error(`Object does not exist: ${e}`);if(t&&!u(t))throw new Error(`Parent does not exist: ${e}`);const r=`User user@example.com ${Math.floor(Date.now()/1e3)} +0000`;let i=`tree ${e}\nauthor ${r}\ncommiter ${r}\n\n${o}\n`;t&&(i=`tree ${e}\nparent ${t}\nauthor ${r}\ncommiter ${r}\n\n${o}\n`);const s=`commit ${i.length}\0`+i,a=S(s);return y(a,n.deflateSync(s)),a})(e,t.parent,t.message);const I=e=>new Date(1e3*parseInt(e.toString("hex"),16)),B=(new e).name("node-git").usage("[option] <command>").version("1.0.0","-v, --version","Output the current version");B.command("init").description("Create an empty node-git repository or reinitialize an existing one.").option("-f","Force reinitialization of existing repository").usage(" ").action((e=>(e=>{!o.existsSync(d)||e.f?(process.stdout.write(o.existsSync(d)?`Reinitialized existing node-git repository in ${d}`:`Initialized empty node-git repository in ${d}`),f()):process.stdout.write("Detected existing node-git repository. Use -f flag to force reinitialize.")})(e))),B.command("cat-file").description("Provide information for repository objects.").argument("<sha1>","Object hash").option("-p","Pretty print object content").option("-t","Instead of the content, show the object type identified by <object>").option("-s","Instead of the content, show the object size identified by <object>").usage("[-pt] <sha1>").action(((e,t)=>{b(e,t)})),B.command("hash-object").description("Calculate SHA1 hash of given file and optionally create a blob from given file.").argument("<file>","Path to file").option("-w","Write object to repository").usage("[-w] <file>").action(((e,t)=>{process.stdout.write(((e,t)=>{const r=o.readFileSync(e),n=`blob ${r.length}\0${r}`;return t.w?$(e):S(n)})(e,t))})),B.command("write-tree").description("Create a tree object from the current index.").action((()=>{process.stdout.write(x())})),B.command("commit-tree").description("Create a new commit object").argument("<tree>","Existing tree object").addOption(new t("-p, --parent <hash>","Commit parent")).addOption(new t("-m, --message <string>","Commit message").makeOptionMandatory()).usage("<tree> [-pm]").action(((e,t)=>{console.log(e,t),process.stdout.write(E(e,t))})),B.command("log").description("Show commit logs").argument("<commit>","Commit to start at.").usage("<commit>").action((e=>{console.log((e=>{if(!e)throw new Error("Not implemented, provide hash");e.slice(0,7);const t=j(e);return t.message=t.message.split("\n")[0],j(e)})(e))})),B.command("ls-files").description("Show information about files in the index and the working tree").action((()=>{console.log((()=>{if(!o.existsSync(".nodegit/index"))throw new Error("Index does not exist");const e=o.readFileSync(".nodegit/index","binary"),t=Buffer.from(e,"binary"),r=t.subarray(0,12),n=r.subarray(0,4);a("DIRC"===n.toString(),"Invalid signature");const i=r.readUIntBE(4,4);a(2===i,"Only version 2 is supported");const s=r.readUIntBE(8,4),c=[];let m=0;const d=t.subarray(r.length);for(let e=0;e<s;e++){const e=d.subarray(m+0,m+4),t=d.subarray(m+8,m+12),o=d.subarray(m+16,m+20),r=d.subarray(m+20,m+24),n=d.subarray(m+24,m+28),i=d.subarray(m+28,m+32),s=d.subarray(m+32,m+36),a=d.readUInt32BE(m+36),l=d.subarray(m+40,m+60),f=d.readUIntBE(m+60,2).toString(2),p=f[0].toString(),u=f[1].toString(),h=parseInt(f.slice(1,3),2),g=4095&parseInt(f,2);let y=null;if(m+=62,!(g<4095))throw new Error(`File name length is too long: ${g} > 4095 bytes`);y=d.subarray(m,m+g).toString("utf8"),m+=g+1,m=8*Math.ceil(m/8),c.push({createdTime:I(e),modifiedTime:I(t),dev:o.toString("hex"),ino:r.toString("hex"),mode:n.toString("hex"),uid:i.toString("hex"),gid:s.toString("hex"),size:a,hash:l.toString("hex"),fileName:y,flags:{binary:f.toString(),valid:p,extended:u,stage:h.toString(2)}})}return c})())})),B.parse(process.argv);
